Go, el reemplazo definitivo de C?
75.24 - Teoría de Lenguajes

* Integrantes :
- Alexis Daciuk
- Nicolás Ledesma
- Federico Longhi
- Lucas Perea

.image images/gopher-1.png

* Origen 

Anunciado en noviembre del 2009, Go nació como un experimento de Robert Griesemer y Rob Pike, ingenieros de Google, junto a Ken Thompson (creador del Lenguaje de programación B, predecesor de C), con el objetivo de diseñar un lenguaje que resuelva problemas comunes de otros lenguajes de programación, sin perder sus características útiles.

Características planeadas del nuevo lenguaje:

- Estáticamente tipado.
- Productivo (?) y fácil de leer, sin mucha repetición ni demasiadas palabras reservadas.
- Sin necesidad de un IDE.
- Con soporte de redes (?) y concurrencia.

En entrevistas posteriores, los 3 creadores comentaron su desagrado de C++, por su innecesaria complejidad.

* Características básicas
- Paradigma: Compilado, concurrente, imperativo, estructurado
- Tipado: fuerte, estático, inferido, estructurado



* Cosas copadas (sujeto a cambios)
- Inferencia de tipos.
- Binarios linkeados estáticamente, es decir, sin dependencias externas.
- AGREGAR MAS.

* Cosas curiosas

.image images/gopher-2.png

* Argument functions vs. Receiver functions 

Funciones clásicas con argumentos

- Definición

        func ladrar(p perro) { // funcion con argumento

- Invocación

        ladrar(p) 


Funciones con un parámetro _receiver_

- Definición

        func (p perro) ladrar() { // funcion con "receiver"

- Invocación

        p.ladrar() // Method, is that you?

*  Comportamiento de ambas

- Ambas formas de definir la función tienen el mismo comportamiento

- Algunos llaman "métodos" a las receiver functions, como si GoLang fuera un lenguaje orientado a objetos.

*¿Cuándo*usar*cada*una?*

- Usar el criterio de la progamación orientada a objetos sería un enfoque erróneo. Go no es un lenguaje OOP. _¿Sólo_los_perros_ladran?_¿Puedo_yo_ladrar_como_un_perro?_.

- Si estamos usando interfaces, es más intuitivo usar receivers para el tipo que está implementando la interfaz.

* Las funciones de Go y sus argumentos

Supongamos que queremos actualizar una estructura aplicándole una función:

.play code/impossibru.go /START OMIT/,/END OMIT/

* ¿Qué hicimos mal? 

.image images/impossibru.png

* ¿Por qué?

- Todas las *funciones* en Go  reciben sus argumentos como *copia*del*valor*. Esta regla *también*aplica*a*las*receiver*functions*.
- En este caso modificamos la copia de Jimmy, pero no a Jimmy.

*¿Cómo*hacemos*lo*que*queríamos*hacer?*

Si una función modifica un valor y queremos que ese cambio persista fuera de la función hay dos opciones:

1. Que la función retorne el valor modificado
2. Que la función reciba un argumento de tipo puntero en lugar de recibir el tipo del valor.

Go permite usar punteros de forma bastante simple. 

* Receiver functions con punteros

No hace falta crear un puntero a 'musician'. Go permite saltearse ese paso, sólo hace falta definir que la función reciba un puntero. 
.play -edit code/impossibru.go /START OMIT/,/END OMIT/

* Comportamiento en los tipos básicos

Ok, entonces deberíamos esperar este comportamiento en los tipos básicos, ¿no?

.play code/impossibru2.go /START OMIT/,/END OMIT/

* ¿Por qué?

.image images/what.jpg

* Tipos por valor y por referencia

*Tipos*por*valor*

- strings, ints, floats, bools, structs

Con estos tipos sería necesario agregar punteros en casos como el anterior.

*Tipos*por*referencia*

- slices, maps, functions, channels, pointers

Los tipos por referencia se valen de estructuras que referencian a donde están realmente los valores, para se pueda operar con ellos.

No sólo no es necesario operar sobre punteros dentro de las funciones, operar con punteros a estas estructuras ocasionaría errores.

* Cuando usar Go



* Cuando no usar Go



* Estadísticas
Top 5 frameworks (según las estadísticas de golanglibs.com)

    - node_exporter : para manejar métricas.
    - stats : Paquete con funciones estadísticas. 
    - gonum : Conjunto de bibliotecas numéricas.
    - bayesian : Clasificador Bayesiano ingenuo.
    - prometheus-operator : Biblioteca para manejar Clusters Prometheus sobre Kubernetes.

Uso (según OpenHub.net)

    - Proyectos : 2 677.
    - Lineas : 122 943 230 de las cuales, 93 518 418 son de código y 17 313 977 son comentarios.
    - Personas contribuyendo : 18 044.
    - Commits : 803 563. 

A Septiembre de 2017, según el ranking TIOBE de popularidad, Go esta en el puesto 17, ascendiendo 2 puestos con respecto al mismo mes del año pasado, en 2016 fue en lenguaje que más popularidad gano.

* Comparación con lenguajes populares

Go vs NodeJS

    - Madurez : Ambos proyectos son bastante maduros, aunque la API de Node esta en constante cambio,
    eso puede traer problemas a futuro futuro
    - Rendimiento : Go tiene un rendimiento similar a C y C++ (es decir, bastante bueno) mientras Node,
     al ser Javascript dinamicamente tipado, no alcanza el nivel de rendimiento de Go.
     dinamicamente tipado, no alcanza el nivel de rendimiento de Go.
    - Concurrencia : Go usa `goroutines` para concurrencia, que se clasifica como green-threads 
    (segun lo que vimos en clase), mientras Node (mas bien JS), usa asincronismo para 
    emular concurrencia a nivel usuario.
    - Escalabilidad : Go fue pensando con 