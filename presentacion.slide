Go, el reemplazo definitivo de C?
75.24 - Teoría de Lenguajes


##########################################################

* Integrantes :
- Alexis Daciuk
- Nicolás Ledesma
- Federico Longhi
- Lucas Perea

.image images/gopher-1.png


##########################################################

* Origen

Anunciado en noviembre del 2009, Go nació como un experimento de Robert Griesemer y Rob Pike, ingenieros de Google, junto a Ken Thompson (creador del Lenguaje de programación B, predecesor de C), con el objetivo de diseñar un lenguaje que resuelva problemas comunes de otros lenguajes de programación, sin perder sus características útiles.

Características planeadas del nuevo lenguaje:

- Estáticamente tipado.
- Productivo (?) y fácil de leer, sin mucha repetición ni demasiadas palabras reservadas.
- Sin necesidad de un IDE.
- Con soporte de redes (?) y concurrencia.

En entrevistas posteriores, los 3 creadores comentaron su desagrado de C++, por su innecesaria complejidad.


##########################################################

* Características básicas
- Paradigma: Compilado, concurrente, imperativo, estructurado
- Tipado: fuerte, estático, inferido, estructurado


##########################################################

* Cosas copadas (sujeto a cambios)
- Inferencia de tipos.
- Binarios linkeados estáticamente, es decir, sin dependencias externas.
- AGREGAR MAS.


##########################################################

* Features importantes

.image images/gopher-3.gif


##########################################################

* Interfaces

- Las interfaces en Go son herramientas para definir comportamientos similares en entidades o estructuras diferentes.

- La implementación de una interfaz es implícita. Basta con que una estructura implemente exactamente las funciones descriptas por la interfaz.

- Mientras int, float, string, etc. son tipos concretos (al declararlos se infiere automáticamente su tipo), el tipo interfaz se infiere una vez que se definen las funciones que implementa la interfaz.

- Las interfaces *no* son tipos genéricos. Simplemente ayudan a encapsular comportamiento dentro de un contrato.

- El comportamiento de *muchas* librerías de Go está encerrado en interfaces.


##########################################################

* Ejemplo

.play code/interfaces.go /START OMIT/,/END OMIT/


##########################################################

* Usos en packages

En el package `io` se define la siguiente interfaz:

        type ReadWriter interface {
            Reader
            Writer
        }

Que a su vez incluye las interfaces `Reader` y `Writer`.

        type Reader interface {
                Read(p []byte) (n int, err error)
        }

        type Writer interface {
                Write(p []byte) (n int, err error)
        }

Varios paquetes utilizan interfaces como `Reader`, por ejemplo, el `body` de un request del paquete `net/http` lo implementa.

.link https://golang.org/pkg/io/


##########################################################

* Goroutines, la implementación de la concurrencia en Go

- Son *green*threads*, más adelante vamos a ahondar en esto

- La sintaxis es *sumamente*simple*. Se trabaja con concurrencia abstrayéndose completamente del manejo de threads.

- El complemento de las goroutines son los *channels*, que sirven justamente como canal de comunicación entre los distintos threads.

.image images/gopher-5.png


##########################################################

* Ejemplo de juguete (I)

Supongamos que quiero resolver lo siguiente en forma concurrente.

.play code/routines-1.go /START OMIT/,/END OMIT/


##########################################################

* Ejemplo de juguete (II)

Basta con poner "`go`" delante del llamado a las funciones para que se ejecuten en goroutines

.play code/routines-2.go /START OMIT/,/END OMIT/


##########################################################

* ¿Qué pasó?

El *hilo*principal*terminó* de ejecutarse *antes*de*que*pudieran*terminar*las*goroutines*.

*¿Cómo*lo*resolvemos?*

Tenemos que acumular los datos obtenidos en un store e imprimirlos en la medida que se obtengan.

Para esto utilizamos *channels*. Los channels son tipados, esto significa que cada uno maneja *un*único*tipo*de*dato*.

.image images/gopher-4.png


##########################################################

* Ejemplo de juguete (III)

.play code/routines-3.go /START OMIT/,/END OMIT/


##########################################################

* Cosas curiosas

.image images/gopher-2.png


##########################################################

* Argument functions vs. Receiver functions

Funciones clásicas con argumentos

- Definición

        func ladrar(p perro) { // funcion con argumento

- Invocación

        ladrar(p)


Funciones con un parámetro _receiver_

- Definición

        func (p perro) ladrar() { // funcion con "receiver"

- Invocación

        p.ladrar() // Method, is that you?


##########################################################

*  Comportamiento de ambas

- Ambas formas de definir la función tienen el mismo comportamiento

- Algunos llaman "métodos" a las receiver functions, como si GoLang fuera un lenguaje orientado a objetos.

*¿Cuándo*usar*cada*una?*

- Usar el criterio de la progamación orientada a objetos sería un enfoque erróneo. Go no es un lenguaje OOP. _¿Sólo_los_perros_ladran?_¿Puedo_yo_ladrar_como_un_perro?_.

- Si estamos usando interfaces, es más intuitivo usar receivers para el tipo que está implementando la interfaz.


##########################################################

* Las funciones de Go y sus argumentos

Supongamos que queremos actualizar una estructura aplicándole una función:

.play code/impossibru.go /START OMIT/,/END OMIT/


##########################################################

* ¿Qué hicimos mal?

.image images/impossibru.png


##########################################################

* ¿Por qué?

- Todas las *funciones* en Go  reciben sus argumentos como *copia*del*valor*. Esta regla *también*aplica*a*las*receiver*functions*.
- En este caso modificamos la copia de Jimmy, pero no a Jimmy.

*¿Cómo*hacemos*lo*que*queríamos*hacer?*

Si una función modifica un valor y queremos que ese cambio persista fuera de la función hay dos opciones:

1. Que la función retorne el valor modificado
2. Que la función reciba un argumento de tipo puntero en lugar de recibir el tipo del valor.

Go permite usar punteros de forma bastante simple.


##########################################################

* Receiver functions con punteros

No hace falta crear un puntero a 'musician'. Go permite saltearse ese paso, sólo hace falta definir que la función reciba un puntero.
.play -edit code/impossibru.go /START OMIT/,/END OMIT/


##########################################################

* Comportamiento en los tipos básicos

Ok, entonces deberíamos esperar este comportamiento en los tipos básicos, ¿no?

.play code/impossibru2.go /START OMIT/,/END OMIT/


##########################################################

* ¿Por qué?

.image images/what.jpg


##########################################################

* Tipos por valor y por referencia

*Tipos*por*valor*

- strings, ints, floats, bools, structs

Con estos tipos sería necesario agregar punteros en casos como el anterior.

*Tipos*por*referencia*

- slices, maps, functions, channels, pointers

Los tipos por referencia se valen de estructuras que referencian a donde están realmente los valores, para se pueda operar con ellos.

No sólo no es necesario operar sobre punteros dentro de las funciones, operar con punteros a estas estructuras ocasionaría errores.


##########################################################

* Cuando usar Go


##########################################################

* Cuando no usar Go


##########################################################

* Estadísticas
Top 5 frameworks (según las estadísticas de golanglibs.com)

        - node_exporter : para manejar métricas.
        - stats : Paquete con funciones estadísticas.
        - gonum : Conjunto de bibliotecas numéricas.
        - bayesian : Clasificador Bayesiano ingenuo.
        - prometheus-operator : Biblioteca para manejar Clusters Prometheus sobre Kubernetes.

Uso (según OpenHub.net)

        - Proyectos : 2 677.
        - Lineas : 122 943 230 de las cuales, 93 518 418 son de código y 17 313 977 son comentarios.
        - Personas contribuyendo : 18 044.
        - Commits : 803 563.

A Septiembre de 2017, según el ranking TIOBE de popularidad, Go esta en el puesto 17, ascendiendo 2 puestos con respecto al mismo mes del año pasado, en 2016 fue en lenguaje que más popularidad gano.


##########################################################

* Comparación con lenguajes populares

Go vs NodeJS

- *Madurez:* Ambos proyectos son bastante maduros, aunque la API de Node esta en constante cambio eso puede traer problemas a futuro futuro
- *Rendimiento:* Go tiene un rendimiento similar a C y C++ (es decir, bastante bueno) mientras Node, al ser Javascript dinamicamente tipado, no alcanza el nivel de rendimiento de Go.
- *Concurrencia:* Go usa `goroutines` para concurrencia, que se clasifica como green-threads (según lo que vimos en clase), mientras Node (mas bien JS), usa asincronismo para emular concurrencia a nivel usuario.
- *Ecosistema:* Mientras Go tiene mas de 58 mil bibliotecas, Node esta muy arriba con mas de 100 mil paquetes.


##########################################################

* Concurrencia en Go

Como se menciono en un slide anterior de esta presentación, concurrencia en Go se maneja con *goroutines*, que son manejados por un scheduler interno de Go y son Green Threads, según lo que vimos en clases pasadas.

- *Consumo* *de* *memoria*

La creación de un *goroutine* necesita nada mas 2 kB de espacio en el stack, de ser necesario, crece asignándose espacio en el heap.

- *Costo* *de* *creación* *y* *destrucción*

Como la creación y la destrucción son manejados por el runtime de Go, así que los costos son bastante bajos.

- *Costo* *de* *cambio* *de* *contexto*

Como las *goroutines* son planificados de forma cooperativa y cuando se cambia de contexto, solamente se necesita guardar 3 registros, *Program* *Counter*, *Stack* *Pointer* y *DX*, por ende, el costo de cambio de contexto es muy bajo.

: Como los schedulers modernos son O(1), la cantidad de goroutines no afecta el costo temporal de cambio de contexto


##########################################################

* Como se ejecutan las goroutines

Al scheduler de Go, solamente tiene en cuenta las goroutines no bloqueadas, a nivel SO, el runtime tiene una cantidad de threads donde las goroutines van a ser ejecutadas, si una goroutine se bloquea, automáticamente el scheduler la saca de ejecución y pone otra goroutine a ejecutarse.

La ejecución es planificada de forma cooperativa.

- *Bloqueo*

Las goroutines no bloquean el thread en el cual se están ejecutando, si están bloqueadas en *requests* *de* *red*, *sleep*, *operaciones* *de* *channels* o en *primitivas* *del* *paquete* *sync*

- *Threads* *a* *nivel* *SO*

Aunque no se pueda controlar manualmente la cantidad de threads que va a crear la runtime, podes limitar la cantidad de threads que puede crear, usando la instrucción *runtime.GOMAXPROC(n)*

: Cooperative schedule :  es un estilo de scheduling, donde cada proceso, voluntariamente cede el control de la CPU al sistema operativo (o runtime, en el caso de Go)


##########################################################

* Caso de estudio : Docker

Docker es un software para manejar y automatizar el trabajo con containers (principalmente en Linux, también en Windows, pero, who cares)

(COMPLETAR CON INFO SOBRE DOCKER)


##########################################################

* Porque usan Go en Docker?

- *Compilación* *estática* *:* *go* *build* compila todo a un solo binario.
No mas "tenes que instalar n dependencias" con n -> ∞, ha no ser que uses *cgo*, que te permite usar cualquier librería de C. O si no contás a *libc* como una dependencia (pero, quien no tiene libc?).

- *Es* *neutral* *:*  No es C++, no es Python, no es Ruby, no es Java.

- *Tiene* *lo* *que* *necesitaban* *:* Buenas primitivas de asincronismo, Interfaces de bajo nivel, extensa libreria standard

- *Duck* *typing* *:* se conoce como duck typing el estilo de tipificación dinámica de datos en que el conjunto actual de métodos y propiedades determina la validez semántica, en vez de que lo hagan la herencia de una clase en particular o la implementación de una interfaz específica.


##########################################################

* Porque usan Go en Docker?

- *Buen* *conjunto* *de* *herramientas*
*go* *doc* *:* para ver la documentacion de un paquete.
*go* *get* *:* para instalar paquetes (github o repositorios propios, basados en git).
*go* *fmt* *:* formateador de codigo (no mas tabs vs espacios).
*go* *test* *:* ejecuta todos los Test* en *_test.go.
*go* *run* *:* ejecuta el codigo en el archivo, sin crear un binario (scripting).

- *Facilidad* *para* *compilar* *multiplataforma*.


##########################################################

* Porque usan Go en Docker?

*Desventajas*

*Los* *maps* *no* *son* *thread-safe*

- Decision intencionada, son _muy_ rapidos.
- Tenes que restringir el acceso mediante Mutex o usar channels de channels.

*Limitaciones* *de* *go* *get*

- No puede descargar versiones especificas, siempre descarga la ultima.
- Docker tuvo que descargar localmente el codigo de todas las dependencias *vendoring* (esto no es malo, es medianamente incomodo).
- Descargar de repositorios privados no es trivial.


##########################################################

* Porque usan Go en Docker?

*Desventajas*

*Limitaciones* *de* *go* *test*
